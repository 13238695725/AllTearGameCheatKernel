#include "draw.h"
#include <fstream>
#include <sstream>
#include <thread>
#include <unordered_map>
#include <algorithm>

struct ClassInfo {
    std::unordered_map<std::string, std::string> members;
};
std::unordered_map<std::string, ClassInfo> classDatabase;
std::string sdkParseResult;
bool showSdkParserWindow = false;
char sdkFilePath[256] = "SDK.txt";
char ruleFilePath[256] = "规则.txt";
char outputFilePath[256] = "result.txt";
bool isParsing = false;
float parseProgress = 0.0f;

std::string trim(const std::string& str) {
    size_t first = str.find_first_not_of(" \t\n\r");
    if (std::string::npos == first) return "";
    size_t last = str.find_last_not_of(" \t\n\r");
    return str.substr(first, (last - first + 1));
}

void BuildClassDatabase(const std::string& sdkContent) {
    classDatabase.clear();
    std::istringstream iss(sdkContent);
    std::string line;
    std::string currentClass;
    
    while (std::getline(iss, line)) {
        line = trim(line);
        if (line.find("Class: ") == 0) {
            currentClass = trim(line.substr(7));
            continue;
        }
        
        if (!currentClass.empty() && line.find("Offset: 0x") != std::string::npos) {
            size_t typeEnd = line.find_first_of(" \t");
            if (typeEnd == std::string::npos) continue;
            
            std::string type = line.substr(0, typeEnd);
            std::string name = line.substr(typeEnd + 1);
            
            size_t nameEnd = name.find_first_of(" \t;");
            if (nameEnd != std::string::npos) name = name.substr(0, nameEnd);
            
            size_t offsetPos = line.find("Offset: 0x");
            if (offsetPos != std::string::npos) {
                std::string offset = line.substr(offsetPos + 8);
                offset = trim(offset.substr(0, offset.find_first_of(" \t\n\r")));
                classDatabase[currentClass].members[name] = offset;
            }
        }
    }
}

std::string ProcessRules(const std::string& ruleContent) {
    std::ostringstream result;
    std::istringstream iss(ruleContent);
    std::string line;
    
    while (std::getline(iss, line)) {
        line = trim(line);
        if (line.empty() || line.find("//") == 0) {
            result << line << "\n";
            continue;
        }
        
        size_t pos1 = line.find('#');
        size_t pos2 = line.find('#', pos1 + 1);
        
        if (pos1 != std::string::npos && pos2 != std::string::npos) {
            std::string funcName = trim(line.substr(0, pos1));
            std::string className = trim(line.substr(pos1 + 1, pos2 - pos1 - 1));
            std::string memberName = trim(line.substr(pos2 + 1));
            
            className = trim(className);
            if (className.find("Class: ") == 0) className = className.substr(7);
            memberName = trim(memberName);
            if (memberName.back() == ';') memberName.pop_back();
            
            auto classIt = classDatabase.find(className);
            if (classIt != classDatabase.end()) {
                auto memberIt = classIt->second.members.find(memberName);
                if (memberIt != classIt->second.members.end()) {
                    result << funcName << "\t\t" << memberIt->second << "\n";
                    continue;
                }
            }
        }
        result << line << "\n";
    }
    return result.str();
}



bool permeate_record = false;
bool permeate_record_ini = false;
struct Last_ImRect LastCoordinate = {0, 0, 0, 0};


std::unique_ptr<AndroidImgui> graphics;
ANativeWindow *window = NULL; 
android::ANativeWindowCreator::DisplayInfo displayInfo;// 屏幕信息
ImGuiWindow *g_window = NULL;// 窗口信息
int abs_ScreenX = 0, abs_ScreenY = 0;// 绝对屏幕X _ Y
int native_window_screen_x = 0, native_window_screen_y = 0;

/*
bool M_Android_LoadFont(float SizePixels) {
    ImGuiIO &io = ImGui::GetIO();
    
    //ImFontConfig config; //oppo字体部分
    //config.FontDataOwnedByAtlas = false;
    //config.SizePixels = SizePixels;
    //config.OversampleH = 1;
    //::zh_font = io.Fonts->AddFontFromMemoryTTF((void *)OPPOSans_H, OPPOSans_H_size, 0.0f, &config, io.Fonts->GetGlyphRangesChineseFull());    
    ////io.Fonts->AddFontDefault(&config);

	static const ImWchar icons_ranges[] = {ICON_MIN_FA, ICON_MAX_FA, 0};
    ImFontConfig icons_config;
    icons_config.MergeMode = true;
    icons_config.PixelSnapH = true;
    icons_config.OversampleH = 3.0;
    icons_config.OversampleV = 3.0;		
    icons_config.SizePixels = SizePixels;
    //icons_config.GlyphOffset.y += 7.0f; // 通过 GlyphOffset 调整单个字形偏移量，向下偏移 size 像素
	::icon_font_0 = io.Fonts->AddFontFromMemoryCompressedTTF((const void *)&font_awesome_brands_compressed_data, sizeof(font_awesome_brands_compressed_data), 0.0f, &icons_config, icons_ranges);
	::icon_font_1 = io.Fonts->AddFontFromMemoryCompressedTTF((const void *)&font_awesome_regular_compressed_data, sizeof(font_awesome_regular_compressed_data), 0.0f, &icons_config, icons_ranges);
	::icon_font_2 = io.Fonts->AddFontFromMemoryCompressedTTF((const void *)&font_awesome_solid_compressed_data, sizeof(font_awesome_solid_compressed_data), 0.0f, &icons_config, icons_ranges);

    io.Fonts->AddFontDefault();
    return zh_font != nullptr;
}*/

void init_My_drawdata() {
    ImGui::StyleColorsLight(); //白色
    ImGui::My_Android_LoadSystemFont(35.0f); //(加载系统字体 安卓15完美适配)
  //  M_Android_LoadFont(25.0f); //加载字体(还有图标)
    ImGui::GetStyle().ScaleAllSizes(3.25f);
 //   ::Aekun_image = graphics->LoadTextureFromMemory((void *)picture_ZhenAiKun_PNG_H, sizeof(picture_ZhenAiKun_PNG_H));
}


void screen_config() {
    ::displayInfo = android::ANativeWindowCreator::GetDisplayInfo();
}

void drawBegin() {
    if (::permeate_record_ini) {
        LastCoordinate.Pos_x = ::g_window->Pos.x;
        LastCoordinate.Pos_y = ::g_window->Pos.y;
        LastCoordinate.Size_x = ::g_window->Size.x;
        LastCoordinate.Size_y = ::g_window->Size.y;

        graphics->Shutdown();
        android::ANativeWindowCreator::Destroy(::window);
        ::window = android::ANativeWindowCreator::Create("test_sysGui", native_window_screen_x, native_window_screen_y, permeate_record);
        graphics->Init_Render(::window, native_window_screen_x, native_window_screen_y);
        ::init_My_drawdata(); //初始化绘制数据
    } 


    static uint32_t orientation = -1;
    screen_config();
    if (orientation != displayInfo.orientation) {
        orientation = displayInfo.orientation;
        Touch::setOrientation(displayInfo.orientation);
        if (g_window != NULL) {
            g_window->Pos.x = 100;
            g_window->Pos.y = 125;        
        }        
        //cout << " width:" << displayInfo.width << " height:" << displayInfo.height << " orientation:" << displayInfo.orientation << endl;
    }
}


void Layout_tick_UI(bool *main_thread_flag) {
    
       if (ImGui::Begin("SDK解析工具 1.0", main_thread_flag)){
        if (::permeate_record_ini) {
            ImGui::SetWindowPos({LastCoordinate.Pos_x, LastCoordinate.Pos_y});
            ImGui::SetWindowSize({LastCoordinate.Size_x, LastCoordinate.Size_y});
            permeate_record_ini = false;   
        }
            ImGui::Text("SDK文件: %s\n", sdkFilePath);
ImGui::SameLine();
            ImGui::Text("规则文件: %s\n", ruleFilePath);
ImGui::SameLine();

            ImGui::Text("输出文件: %s\n", outputFilePath);
ImGui::SameLine();

            
            if (ImGui::Button("解析 bymz1599569296") && !isParsing) {
                isParsing = true;
                parseProgress = 0.0f;
                std::thread([&]() {
                    std::ifstream sdkFile(sdkFilePath);
                    if (!sdkFile) {
                        sdkParseResult = "无法打开SDK文件";
                        isParsing = false;
                        return;
                    }
                    std::string sdkContent((std::istreambuf_iterator<char>(sdkFile)), std::istreambuf_iterator<char>());
                    parseProgress = 0.3f;
                    BuildClassDatabase(sdkContent);
                    parseProgress = 0.6f;
                    
                    std::ifstream ruleFile(ruleFilePath);
                    if (!ruleFile) {
                        sdkParseResult = "无法打开规则文件";
                        isParsing = false;
                        return;
                    }
                    std::string ruleContent((std::istreambuf_iterator<char>(ruleFile)), std::istreambuf_iterator<char>());
                    parseProgress = 0.8f;
                    sdkParseResult = ProcessRules(ruleContent);
                    parseProgress = 1.0f;
                    
                    std::ofstream outFile(outputFilePath);
                    outFile << sdkParseResult;
                    isParsing = false;
                }).detach();
            }
            
            if (isParsing) {
                ImGui::SameLine();
                ImGui::ProgressBar(parseProgress, ImVec2(100, 20));
            }
            
            if (!sdkParseResult.empty()) {
                ImGui::Separator();
                ImGui::Text("解析结果:");
                ImGui::BeginChild("Result", ImVec2(600, 400), true);
                ImGui::TextUnformatted(sdkParseResult.c_str());
                ImGui::EndChild();
                
                if (ImGui::Button("保存结果")) {
                    std::ofstream outFile(outputFilePath);
                    outFile << sdkParseResult;
                    ImGui::OpenPopup("保存成功");
                    printf("结果已保存到: %s\n", outputFilePath);
                }
            }
          }
            g_window = ImGui::GetCurrentWindow();
            ImGui::End();
    }